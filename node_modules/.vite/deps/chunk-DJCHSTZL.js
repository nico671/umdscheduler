import {
  derived,
  readable,
  writable
} from "./chunk-ZITOXSUL.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  append_hydration_dev,
  attr_dev,
  beforeUpdate,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  getContext,
  get_store_value,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  prop_dev,
  run_all,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  validate_slots,
  validate_store
} from "./chunk-EVUIGUWR.js";

// node_modules/@event-calendar/core/src/Calendar.svelte
import "/Users/nicocarbone/Documents/dev/umdscheduler/frontend/node_modules/@event-calendar/core/index.css";

// node_modules/@event-calendar/core/src/lib/a11y.js
function keyEnter(fn) {
  return function(e) {
    return e.key === "Enter" || e.key === " " && !e.preventDefault() ? fn.call(this, e) : void 0;
  };
}

// node_modules/@event-calendar/core/src/lib/actions.js
function setContent(node, content) {
  let actions = {
    update(content2) {
      if (typeof content2 == "string") {
        node.innerText = content2;
      } else if (content2 == null ? void 0 : content2.domNodes) {
        node.replaceChildren(...content2.domNodes);
      } else if (content2 == null ? void 0 : content2.html) {
        node.innerHTML = content2.html;
      }
    }
  };
  actions.update(content);
  return actions;
}
function outsideEvent(node, type) {
  const handlePointerDown = (jsEvent) => {
    if (node && !node.contains(jsEvent.target)) {
      node.dispatchEvent(
        new CustomEvent(type + "outside", { detail: { jsEvent } })
      );
    }
  };
  document.addEventListener(type, handlePointerDown, true);
  return {
    destroy() {
      document.removeEventListener(type, handlePointerDown, true);
    }
  };
}

// node_modules/@event-calendar/core/src/lib/date.js
var DAY_IN_SECONDS = 86400;
function createDate(input = void 0) {
  if (input !== void 0) {
    return input instanceof Date ? _fromLocalDate(input) : _fromISOString(input);
  }
  return _fromLocalDate(/* @__PURE__ */ new Date());
}
function createDuration(input) {
  if (typeof input === "number") {
    input = { seconds: input };
  } else if (typeof input === "string") {
    let seconds = 0, exp = 2;
    for (let part of input.split(":", 3)) {
      seconds += parseInt(part, 10) * Math.pow(60, exp--);
    }
    input = { seconds };
  } else if (input instanceof Date) {
    input = { hours: input.getUTCHours(), minutes: input.getUTCMinutes(), seconds: input.getUTCSeconds() };
  }
  let weeks = input.weeks || input.week || 0;
  return {
    years: input.years || input.year || 0,
    months: input.months || input.month || 0,
    days: weeks * 7 + (input.days || input.day || 0),
    seconds: (input.hours || input.hour || 0) * 60 * 60 + (input.minutes || input.minute || 0) * 60 + (input.seconds || input.second || 0),
    inWeeks: !!weeks
  };
}
function cloneDate(date) {
  return new Date(date.getTime());
}
function addDuration(date, duration, x = 1) {
  date.setUTCFullYear(date.getUTCFullYear() + x * duration.years);
  let month = date.getUTCMonth() + x * duration.months;
  date.setUTCMonth(month);
  month %= 12;
  if (month < 0) {
    month += 12;
  }
  while (date.getUTCMonth() !== month) {
    subtractDay(date);
  }
  date.setUTCDate(date.getUTCDate() + x * duration.days);
  date.setUTCSeconds(date.getUTCSeconds() + x * duration.seconds);
  return date;
}
function subtractDuration(date, duration, x = 1) {
  return addDuration(date, duration, -x);
}
function addDay(date, x = 1) {
  date.setUTCDate(date.getUTCDate() + x);
  return date;
}
function subtractDay(date, x = 1) {
  return addDay(date, -x);
}
function setMidnight(date) {
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function toLocalDate(date) {
  return new Date(
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds()
  );
}
function toISOString(date, len = 19) {
  return date.toISOString().substring(0, len);
}
function datesEqual(date1, ...dates2) {
  return dates2.every((date2) => date1.getTime() === date2.getTime());
}
function nextClosestDay(date, day) {
  let diff2 = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff2 >= 0 ? diff2 : diff2 + 7));
  return date;
}
function prevClosestDay(date, day) {
  let diff2 = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff2 <= 0 ? diff2 : diff2 - 7));
  return date;
}
function noTimePart(date) {
  return typeof date === "string" && date.length <= 10;
}
function copyTime(toDate, fromDate) {
  toDate.setUTCHours(fromDate.getUTCHours(), fromDate.getUTCMinutes(), fromDate.getUTCSeconds(), 0);
  return toDate;
}
function toSeconds(duration) {
  return duration.seconds;
}
function nextDate(date, duration) {
  addDuration(date, duration);
  return date;
}
function prevDate(date, duration, hiddenDays) {
  subtractDuration(date, duration);
  if (hiddenDays.length && hiddenDays.length < 7) {
    while (hiddenDays.includes(date.getUTCDay())) {
      subtractDay(date);
    }
  }
  return date;
}
function _fromLocalDate(date) {
  return new Date(Date.UTC(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds()
  ));
}
function _fromISOString(str) {
  const parts = str.match(/\d+/g);
  return new Date(Date.UTC(
    Number(parts[0]),
    Number(parts[1]) - 1,
    Number(parts[2]),
    Number(parts[3] || 0),
    Number(parts[4] || 0),
    Number(parts[5] || 0)
  ));
}

// node_modules/@event-calendar/core/src/lib/utils.js
function assign(...args) {
  return Object.assign(...args);
}
function keys(object) {
  return Object.keys(object);
}
function floor(value) {
  return Math.floor(value);
}
function ceil(value) {
  return Math.ceil(value);
}
function min(...args) {
  return Math.min(...args);
}
function max(...args) {
  return Math.max(...args);
}
function symbol() {
  return Symbol("ec");
}
function isArray(value) {
  return Array.isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function run(fn) {
  return fn();
}
function runAll(fns) {
  fns.forEach(run);
}
function noop2() {
}
var identity = (x) => x;

// node_modules/@event-calendar/core/src/lib/debounce.js
function debounce(fn, handle, queueStore) {
  queueStore.update((queue) => queue.set(handle, fn));
}
function flushDebounce(queue) {
  runAll(queue);
  queue.clear();
}
function task(fn, handle, tasks) {
  handle ?? (handle = fn);
  if (!tasks.has(handle)) {
    tasks.set(handle, setTimeout(() => {
      tasks.delete(handle);
      fn();
    }));
  }
}

// node_modules/@event-calendar/core/src/lib/payload.js
var payloadProp = symbol();
function setPayload(obj, payload) {
  obj[payloadProp] = payload;
}
function hasPayload(obj) {
  return !!(obj == null ? void 0 : obj[payloadProp]);
}
function getPayload(obj) {
  return obj[payloadProp];
}

// node_modules/@event-calendar/core/src/lib/dom.js
function createElement(tag, className, content, attrs = []) {
  let el = document.createElement(tag);
  el.className = className;
  if (typeof content == "string") {
    el.innerText = content;
  } else if (content.domNodes) {
    el.replaceChildren(...content.domNodes);
  } else if (content.html) {
    el.innerHTML = content.html;
  }
  for (let attr of attrs) {
    el.setAttribute(...attr);
  }
  return el;
}
function hasYScroll(el) {
  return el.scrollHeight > el.clientHeight;
}
function rect(el) {
  return el.getBoundingClientRect();
}
function ancestor(el, up) {
  while (up--) {
    el = el.parentElement;
  }
  return el;
}
function height(el) {
  return rect(el).height;
}
function getElementWithPayload(x, y, root = document) {
  for (let el of root.elementsFromPoint(x, y)) {
    if (hasPayload(el)) {
      return el;
    }
    if (el.shadowRoot) {
      let shadowEl = getElementWithPayload(x, y, el.shadowRoot);
      if (shadowEl) {
        return shadowEl;
      }
    }
  }
  return null;
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}

// node_modules/@event-calendar/core/src/lib/view.js
function createView(view2, _viewTitle, _currentRange, _activeRange) {
  return {
    type: view2,
    title: _viewTitle,
    currentStart: _currentRange.start,
    currentEnd: _currentRange.end,
    activeStart: _activeRange.start,
    activeEnd: _activeRange.end,
    calendar: void 0
  };
}
function toViewWithLocalDates(view2) {
  view2 = assign({}, view2);
  view2.currentStart = toLocalDate(view2.currentStart);
  view2.currentEnd = toLocalDate(view2.currentEnd);
  view2.activeStart = toLocalDate(view2.activeStart);
  view2.activeEnd = toLocalDate(view2.activeEnd);
  return view2;
}
function listView(view2) {
  return view2.startsWith("list");
}
function timelineView(view2) {
  return view2.includes("Timeline");
}

// node_modules/@event-calendar/core/src/lib/events.js
var eventId = 1;
function createEvents(input) {
  return input.map((event) => {
    let result = {
      id: "id" in event ? String(event.id) : `{generated-${eventId++}}`,
      resourceIds: toArrayProp(event, "resourceId").map(String),
      allDay: event.allDay ?? (noTimePart(event.start) && noTimePart(event.end)),
      start: createDate(event.start),
      end: createDate(event.end),
      title: event.title ?? "",
      editable: event.editable,
      startEditable: event.startEditable,
      durationEditable: event.durationEditable,
      display: event.display ?? "auto",
      extendedProps: event.extendedProps ?? {},
      backgroundColor: event.backgroundColor ?? event.color,
      textColor: event.textColor,
      classNames: toArrayProp(event, "className"),
      styles: toArrayProp(event, "style")
    };
    if (result.allDay) {
      setMidnight(result.start);
      let end = cloneDate(result.end);
      setMidnight(result.end);
      if (!datesEqual(result.end, end) || datesEqual(result.end, result.start)) {
        addDay(result.end);
      }
    }
    return result;
  });
}
function toArrayProp(input, propName) {
  let result = input[propName + "s"] ?? input[propName] ?? [];
  return isArray(result) ? result : [result];
}
function createEventSources(input) {
  return input.map((source) => ({
    events: source.events,
    url: source.url && source.url.trimEnd("&") || "",
    method: source.method && source.method.toUpperCase() || "GET",
    extraParams: source.extraParams || {}
  }));
}
function createEventChunk(event, start, end) {
  return {
    start: event.start > start ? event.start : start,
    end: event.end < end ? event.end : end,
    event
  };
}
function sortEventChunks(chunks) {
  chunks.sort((a, b) => a.start - b.start || b.event.allDay - a.event.allDay);
}
function createEventContent(chunk, displayEventEnd, eventContent, theme, _intlEventTime, _view) {
  let timeText = _intlEventTime.formatRange(
    chunk.start,
    displayEventEnd && chunk.event.display !== "pointer" && !chunk.zeroDuration ? copyTime(cloneDate(chunk.start), chunk.end) : chunk.start
  );
  let content;
  if (eventContent) {
    content = isFunction(eventContent) ? eventContent({
      event: toEventWithLocalDates(chunk.event),
      timeText,
      view: toViewWithLocalDates(_view)
    }) : eventContent;
  }
  if (content === void 0) {
    let domNodes;
    switch (chunk.event.display) {
      case "background":
        domNodes = [];
        break;
      case "pointer":
        domNodes = [createTimeElement(timeText, chunk, theme)];
        break;
      default:
        domNodes = [
          ...chunk.event.allDay ? [] : [createTimeElement(timeText, chunk, theme)],
          createElement("h4", theme.eventTitle, chunk.event.title)
        ];
    }
    content = { domNodes };
  }
  return [timeText, content];
}
function handleZeroDurationChunk(chunk, preferredDuration) {
  if (datesEqual(chunk.start, chunk.end)) {
    chunk.zeroDuration = true;
    chunk.end = addDuration(cloneDate(chunk.end), preferredDuration);
  }
}
function createTimeElement(timeText, chunk, theme) {
  return createElement(
    "time",
    theme.eventTime,
    timeText,
    [["datetime", toISOString(chunk.start)]]
  );
}
function createEventClasses(eventClassNames, event, _view) {
  let result = event.classNames;
  if (eventClassNames) {
    if (isFunction(eventClassNames)) {
      eventClassNames = eventClassNames({
        event: toEventWithLocalDates(event),
        view: toViewWithLocalDates(_view)
      });
    }
    result = [
      ...isArray(eventClassNames) ? eventClassNames : [eventClassNames],
      ...result
    ];
  }
  return result;
}
function toEventWithLocalDates(event) {
  return _cloneEvent(event, toLocalDate);
}
function cloneEvent(event) {
  return _cloneEvent(event, cloneDate);
}
function _cloneEvent(event, dateFn) {
  event = assign({}, event);
  event.start = dateFn(event.start);
  event.end = dateFn(event.end);
  return event;
}
function prepareEventChunks(chunks, hiddenDays) {
  let longChunks = {};
  if (chunks.length) {
    sortEventChunks(chunks);
    let prevChunk;
    for (let chunk of chunks) {
      let dates = [];
      let date = setMidnight(cloneDate(chunk.start));
      while (chunk.end > date) {
        if (!hiddenDays.includes(date.getUTCDay())) {
          dates.push(cloneDate(date));
          if (dates.length > 1) {
            let key = date.getTime();
            if (longChunks[key]) {
              longChunks[key].chunks.push(chunk);
            } else {
              longChunks[key] = {
                sorted: false,
                chunks: [chunk]
              };
            }
          }
        }
        addDay(date);
      }
      if (dates.length) {
        chunk.date = dates[0];
        chunk.days = dates.length;
        chunk.dates = dates;
        if (chunk.start < dates[0]) {
          chunk.start = dates[0];
        }
        let maxEnd = addDay(cloneDate(dates.at(-1)));
        if (chunk.end > maxEnd) {
          chunk.end = maxEnd;
        }
      } else {
        chunk.date = setMidnight(cloneDate(chunk.start));
        chunk.days = 1;
        chunk.dates = [chunk.date];
      }
      if (prevChunk && datesEqual(prevChunk.date, chunk.date)) {
        chunk.prev = prevChunk;
      }
      prevChunk = chunk;
    }
  }
  return longChunks;
}
function repositionEvent(chunk, longChunks, height2) {
  chunk.top = 0;
  if (chunk.prev) {
    chunk.top = chunk.prev.bottom + 1;
  }
  chunk.bottom = chunk.top + height2;
  let margin = 1;
  let key = chunk.date.getTime();
  if (longChunks[key]) {
    if (!longChunks[key].sorted) {
      longChunks[key].chunks.sort((a, b) => a.top - b.top);
      longChunks[key].sorted = true;
    }
    for (let longChunk of longChunks[key].chunks) {
      if (chunk.top < longChunk.bottom && chunk.bottom > longChunk.top) {
        let offset = longChunk.bottom - chunk.top + 1;
        margin += offset;
        chunk.top += offset;
        chunk.bottom += offset;
      }
    }
  }
  return margin;
}
function runReposition(refs, data) {
  var _a;
  refs.length = data.length;
  let result = [];
  for (let ref of refs) {
    result.push((_a = ref == null ? void 0 : ref.reposition) == null ? void 0 : _a.call(ref));
  }
  return result;
}
function eventIntersects(event, start, end, resources) {
  if (event.start < end && event.end > start) {
    if (resources) {
      if (!isArray(resources)) {
        resources = [resources];
      }
      return resources.some((resource) => event.resourceIds.includes(resource.id));
    }
    return true;
  }
  return false;
}
function helperEvent(display) {
  return previewEvent(display) || ghostEvent(display) || pointerEvent(display);
}
function bgEvent(display) {
  return display === "background";
}
function previewEvent(display) {
  return display === "preview";
}
function ghostEvent(display) {
  return display === "ghost";
}
function pointerEvent(display) {
  return display === "pointer";
}

// node_modules/@event-calendar/core/src/lib/options.js
function btnTextDay(text2) {
  return btnText(text2, "day");
}
function btnTextWeek(text2) {
  return btnText(text2, "week");
}
function btnTextMonth(text2) {
  return btnText(text2, "month");
}
function btnTextYear(text2) {
  return btnText(text2, "year");
}
function btnText(text2, period) {
  return {
    ...text2,
    next: "Next " + period,
    prev: "Previous " + period
  };
}
function themeView(view2) {
  return (theme) => ({ ...theme, view: view2 });
}

// node_modules/@event-calendar/core/src/lib/resources.js
function createResources(input) {
  let result = [];
  _createResources(input, 0, result);
  return result;
}
function _createResources(input, level, flat) {
  let result = [];
  for (let item of input) {
    let resource = createResource(item);
    result.push(resource);
    flat.push(resource);
    let payload = {
      level,
      children: [],
      expanded: true,
      hidden: false
    };
    setPayload(resource, payload);
    if (item.children) {
      payload.children = _createResources(item.children, level + 1, flat);
    }
  }
  return result;
}
function createResource(input) {
  return {
    id: String(input.id),
    title: input.title || "",
    eventBackgroundColor: input.eventBackgroundColor,
    eventTextColor: input.eventTextColor,
    extendedProps: input.extendedProps ?? {}
  };
}
function resourceBackgroundColor(event, resources) {
  var _a;
  return (_a = findResource(event, resources)) == null ? void 0 : _a.eventBackgroundColor;
}
function resourceTextColor(event, resources) {
  var _a;
  return (_a = findResource(event, resources)) == null ? void 0 : _a.eventTextColor;
}
function findResource(event, resources) {
  return resources.find((resource) => event.resourceIds.includes(resource.id));
}

// node_modules/@event-calendar/core/src/lib/stores.js
function intl(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    let intl2 = isFunction($format) ? { format: $format } : new Intl.DateTimeFormat($locale, $format);
    return {
      format: (date) => intl2.format(toLocalDate(date))
    };
  });
}
function intlRange(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    let formatRange;
    if (isFunction($format)) {
      formatRange = $format;
    } else {
      let intl2 = new Intl.DateTimeFormat($locale, $format);
      formatRange = (start, end) => {
        if (start <= end) {
          return intl2.formatRange(start, end);
        } else {
          let parts = intl2.formatRangeToParts(end, start);
          let result = "";
          let sources = ["startRange", "endRange"];
          let processed = [false, false];
          for (let part of parts) {
            let i = sources.indexOf(part.source);
            if (i >= 0) {
              if (!processed[i]) {
                result += _getParts(sources[1 - i], parts);
                processed[i] = true;
              }
            } else {
              result += part.value;
            }
          }
          return result;
        }
      };
    }
    return {
      formatRange: (start, end) => formatRange(toLocalDate(start), toLocalDate(end))
    };
  });
}
function _getParts(source, parts) {
  let result = "";
  for (let part of parts) {
    if (part.source == source) {
      result += part.value;
    }
  }
  return result;
}
function viewResources(state) {
  return derived(
    [state.resources, state.filterResourcesWithEvents, state._events, state._activeRange],
    ([$resources, $filterResourcesWithEvents, $_events, $_activeRange]) => {
      let result = $resources.filter((resource) => !getPayload(resource).hidden);
      if ($filterResourcesWithEvents) {
        result = $resources.filter((resource) => {
          for (let event of $_events) {
            if (event.display !== "background" && event.resourceIds.includes(resource.id) && event.start < $_activeRange.end && event.end > $_activeRange.start) {
              return true;
            }
          }
          return false;
        });
      }
      if (!result.length) {
        result = createResources([{}]);
      }
      return result;
    }
  );
}

// node_modules/@event-calendar/core/src/lib/times.js
function createTimes(date, $slotDuration, $_slotTimeLimits, $_intlSlotLabel) {
  date = cloneDate(date);
  let compact = $slotDuration.seconds < 3600;
  let times = [];
  let end = cloneDate(date);
  let i = 1;
  addDuration(date, $_slotTimeLimits.min);
  addDuration(end, $_slotTimeLimits.max);
  while (date < end) {
    times.push([
      toISOString(date),
      $_intlSlotLabel.format(date),
      times.length && (i || !compact)
    ]);
    addDuration(date, $slotDuration);
    i = 1 - i;
  }
  return times;
}
function createSlotTimeLimits($slotMinTime, $slotMaxTime, $flexibleSlotTimeLimits, $_viewDates, $_events) {
  let min2 = createDuration($slotMinTime);
  let max2 = createDuration($slotMaxTime);
  if ($flexibleSlotTimeLimits) {
    let minMin = createDuration(min(toSeconds(min2), max(0, toSeconds(max2) - DAY_IN_SECONDS)));
    let maxMax = createDuration(max(toSeconds(max2), toSeconds(minMin) + DAY_IN_SECONDS));
    let filter = isFunction($flexibleSlotTimeLimits == null ? void 0 : $flexibleSlotTimeLimits.eventFilter) ? $flexibleSlotTimeLimits.eventFilter : (event) => !bgEvent(event.display);
    loop:
      for (let date of $_viewDates) {
        let start = addDuration(cloneDate(date), min2);
        let end = addDuration(cloneDate(date), max2);
        let minStart = addDuration(cloneDate(date), minMin);
        let maxEnd = addDuration(cloneDate(date), maxMax);
        for (let event of $_events) {
          if (!event.allDay && filter(event) && event.start < maxEnd && event.end > minStart) {
            if (event.start < start) {
              let seconds = max((event.start - date) / 1e3, toSeconds(minMin));
              if (seconds < toSeconds(min2)) {
                min2.seconds = seconds;
              }
            }
            if (event.end > end) {
              let seconds = min((event.end - date) / 1e3, toSeconds(maxMax));
              if (seconds > toSeconds(max2)) {
                max2.seconds = seconds;
              }
            }
            if (toSeconds(min2) === toSeconds(minMin) && toSeconds(max2) === toSeconds(maxMax)) {
              break loop;
            }
          }
        }
      }
  }
  return { min: min2, max: max2 };
}

// node_modules/@event-calendar/core/src/storage/options.js
function createOptions(plugins) {
  var _a;
  let options = {
    allDayContent: void 0,
    allDaySlot: true,
    buttonText: {
      today: "today"
    },
    customButtons: {},
    date: /* @__PURE__ */ new Date(),
    datesSet: void 0,
    dayHeaderFormat: {
      weekday: "short",
      month: "numeric",
      day: "numeric"
    },
    dayHeaderAriaLabelFormat: {
      dateStyle: "full"
    },
    displayEventEnd: true,
    duration: { weeks: 1 },
    events: [],
    eventAllUpdated: void 0,
    eventBackgroundColor: void 0,
    eventTextColor: void 0,
    eventClassNames: void 0,
    eventClick: void 0,
    eventColor: void 0,
    eventContent: void 0,
    eventDidMount: void 0,
    eventMouseEnter: void 0,
    eventMouseLeave: void 0,
    eventSources: [],
    eventTimeFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    filterEventsWithResources: false,
    filterResourcesWithEvents: false,
    firstDay: 0,
    flexibleSlotTimeLimits: false,
    // ec option
    headerToolbar: {
      start: "title",
      center: "",
      end: "today prev,next"
    },
    height: void 0,
    hiddenDays: [],
    highlightedDates: [],
    // ec option
    lazyFetching: true,
    loading: void 0,
    locale: void 0,
    nowIndicator: false,
    resourceLabelContent: void 0,
    resourceLabelDidMount: void 0,
    resources: [],
    selectable: false,
    scrollTime: "06:00:00",
    slotDuration: "00:30:00",
    slotEventOverlap: true,
    slotHeight: 24,
    // ec option
    slotLabelFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    slotMaxTime: "24:00:00",
    slotMinTime: "00:00:00",
    slotWidth: 72,
    theme: {
      allDay: "ec-all-day",
      active: "ec-active",
      bgEvent: "ec-bg-event",
      bgEvents: "ec-bg-events",
      body: "ec-body",
      button: "ec-button",
      buttonGroup: "ec-button-group",
      calendar: "ec",
      compact: "ec-compact",
      content: "ec-content",
      day: "ec-day",
      dayHead: "ec-day-head",
      days: "ec-days",
      event: "ec-event",
      eventBody: "ec-event-body",
      eventTime: "ec-event-time",
      eventTitle: "ec-event-title",
      events: "ec-events",
      extra: "ec-extra",
      handle: "ec-handle",
      header: "ec-header",
      hiddenScroll: "ec-hidden-scroll",
      highlight: "ec-highlight",
      icon: "ec-icon",
      line: "ec-line",
      lines: "ec-lines",
      nowIndicator: "ec-now-indicator",
      otherMonth: "ec-other-month",
      resource: "ec-resource",
      sidebar: "ec-sidebar",
      sidebarTitle: "ec-sidebar-title",
      today: "ec-today",
      time: "ec-time",
      title: "ec-title",
      toolbar: "ec-toolbar",
      view: "",
      weekdays: ["ec-sun", "ec-mon", "ec-tue", "ec-wed", "ec-thu", "ec-fri", "ec-sat"],
      withScroll: "ec-with-scroll"
    },
    titleFormat: {
      year: "numeric",
      month: "short",
      day: "numeric"
    },
    view: void 0,
    viewDidMount: void 0,
    views: {}
  };
  for (let plugin of plugins) {
    (_a = plugin.createOptions) == null ? void 0 : _a.call(plugin, options);
  }
  return options;
}
function createParsers(plugins) {
  var _a;
  let parsers = {
    date: (date) => setMidnight(createDate(date)),
    duration: createDuration,
    events: createEvents,
    eventSources: createEventSources,
    hiddenDays: (days) => [...new Set(days)],
    highlightedDates: (dates) => dates.map((date) => setMidnight(createDate(date))),
    resources: createResources,
    scrollTime: createDuration,
    slotDuration: createDuration,
    slotMaxTime: createDuration,
    slotMinTime: createDuration
  };
  for (let plugin of plugins) {
    (_a = plugin.createParsers) == null ? void 0 : _a.call(plugin, parsers);
  }
  return parsers;
}
function diff(options, prevOptions) {
  let diff2 = [];
  for (let key of keys(options)) {
    if (options[key] !== prevOptions[key]) {
      diff2.push([key, options[key]]);
    }
  }
  assign(prevOptions, options);
  return diff2;
}

// node_modules/@event-calendar/core/src/storage/stores.js
function dayGrid(state) {
  return derived(state.view, ($view) => $view == null ? void 0 : $view.startsWith("dayGrid"));
}
function activeRange(state) {
  return derived(
    [state._currentRange, state.firstDay, state.slotMaxTime, state._dayGrid],
    ([$_currentRange, $firstDay, $slotMaxTime, $_dayGrid]) => {
      let start = cloneDate($_currentRange.start);
      let end = cloneDate($_currentRange.end);
      if ($_dayGrid) {
        prevClosestDay(start, $firstDay);
        nextClosestDay(end, $firstDay);
      } else if ($slotMaxTime.days || $slotMaxTime.seconds > DAY_IN_SECONDS) {
        addDuration(subtractDay(end), $slotMaxTime);
        let start2 = subtractDay(cloneDate(end));
        if (start2 < start) {
          start = start2;
        }
      }
      return { start, end };
    }
  );
}
function currentRange(state) {
  return derived(
    [state.date, state.duration, state.firstDay],
    ([$date, $duration, $firstDay]) => {
      let start = cloneDate($date), end;
      if ($duration.months) {
        start.setUTCDate(1);
      } else if ($duration.inWeeks) {
        prevClosestDay(start, $firstDay);
      }
      end = addDuration(cloneDate(start), $duration);
      return { start, end };
    }
  );
}
function viewDates(state) {
  return derived([state._activeRange, state.hiddenDays], ([$_activeRange, $hiddenDays]) => {
    let dates = [];
    let date = setMidnight(cloneDate($_activeRange.start));
    let end = setMidnight(cloneDate($_activeRange.end));
    while (date < end) {
      if (!$hiddenDays.includes(date.getUTCDay())) {
        dates.push(cloneDate(date));
      }
      addDay(date);
    }
    if (!dates.length && $hiddenDays.length && $hiddenDays.length < 7) {
      state.date.update((date2) => {
        while ($hiddenDays.includes(date2.getUTCDay())) {
          addDay(date2);
        }
        return date2;
      });
      dates = get_store_value(state._viewDates);
    }
    return dates;
  });
}
function viewTitle(state) {
  return derived(
    [state.date, state._activeRange, state._intlTitle, state._dayGrid],
    ([$date, $_activeRange, $_intlTitle, $_dayGrid]) => {
      return $_dayGrid ? $_intlTitle.formatRange($date, $date) : $_intlTitle.formatRange($_activeRange.start, subtractDay(cloneDate($_activeRange.end)));
    }
  );
}
function view(state) {
  return derived([state.view, state._viewTitle, state._currentRange, state._activeRange], (args) => createView(...args));
}
function events(state) {
  let _events = writable([]);
  let abortController;
  let fetching = 0;
  let debounceHandle = {};
  derived(
    [state.events, state.eventSources, state._activeRange, state._fetchedRange, state.lazyFetching, state.loading],
    (values, set) => debounce(() => {
      let [$events, $eventSources, $_activeRange, $_fetchedRange, $lazyFetching, $loading] = values;
      if (!$eventSources.length) {
        set($events);
        return;
      }
      if (!$_fetchedRange.start || $_fetchedRange.start > $_activeRange.start || $_fetchedRange.end < $_activeRange.end || !$lazyFetching) {
        if (abortController) {
          abortController.abort();
        }
        abortController = new AbortController();
        if (isFunction($loading) && !fetching) {
          $loading(true);
        }
        let stopLoading = () => {
          if (--fetching === 0 && isFunction($loading)) {
            $loading(false);
          }
        };
        let events2 = [];
        let failure = (e) => stopLoading();
        let success = (data) => {
          events2 = events2.concat(createEvents(data));
          set(events2);
          stopLoading();
        };
        let startStr = toISOString($_activeRange.start);
        let endStr = toISOString($_activeRange.end);
        for (let source of $eventSources) {
          if (isFunction(source.events)) {
            let result = source.events({
              start: toLocalDate($_activeRange.start),
              end: toLocalDate($_activeRange.end),
              startStr,
              endStr
            }, success, failure);
            if (result !== void 0) {
              Promise.resolve(result).then(success, failure);
            }
          } else {
            let params = isFunction(source.extraParams) ? source.extraParams() : assign({}, source.extraParams);
            params.start = startStr;
            params.end = endStr;
            params = new URLSearchParams(params);
            let url = source.url, headers = {}, body;
            if (["GET", "HEAD"].includes(source.method)) {
              url += (url.includes("?") ? "&" : "?") + params;
            } else {
              headers["content-type"] = "application/x-www-form-urlencoded;charset=UTF-8";
              body = String(params);
            }
            fetch(url, { method: source.method, headers, body, signal: abortController.signal, credentials: "same-origin" }).then((response) => response.json()).then(success).catch(failure);
          }
          ++fetching;
        }
        $_fetchedRange.start = $_activeRange.start;
        $_fetchedRange.end = $_activeRange.end;
      }
    }, debounceHandle, state._queue),
    []
  ).subscribe(_events.set);
  return _events;
}
function now() {
  return readable(createDate(), (set) => {
    let interval = setInterval(() => {
      set(createDate());
    }, 1e3);
    return () => clearInterval(interval);
  });
}
function today(state) {
  return derived(state._now, ($_now) => setMidnight(cloneDate($_now)));
}

// node_modules/@event-calendar/core/src/storage/state.js
var state_default = class {
  constructor(plugins, input) {
    var _a, _b;
    plugins = plugins || [];
    let options = createOptions(plugins);
    let parsers = createParsers(plugins);
    options = parseOpts(options, parsers);
    input = parseOpts(input, parsers);
    for (let [option, value] of Object.entries(options)) {
      this[option] = writable(value);
    }
    this._queue = writable(/* @__PURE__ */ new Map());
    this._queue2 = writable(/* @__PURE__ */ new Map());
    this._tasks = /* @__PURE__ */ new Map();
    this._auxiliary = writable([]);
    this._dayGrid = dayGrid(this);
    this._currentRange = currentRange(this);
    this._activeRange = activeRange(this);
    this._fetchedRange = writable({ start: void 0, end: void 0 });
    this._events = events(this);
    this._now = now();
    this._today = today(this);
    this._intlEventTime = intlRange(this.locale, this.eventTimeFormat);
    this._intlSlotLabel = intl(this.locale, this.slotLabelFormat);
    this._intlDayHeader = intl(this.locale, this.dayHeaderFormat);
    this._intlDayHeaderAL = intl(this.locale, this.dayHeaderAriaLabelFormat);
    this._intlTitle = intlRange(this.locale, this.titleFormat);
    this._bodyEl = writable(void 0);
    this._scrollable = writable(false);
    this._viewTitle = viewTitle(this);
    this._viewDates = viewDates(this);
    this._view = view(this);
    this._viewComponent = writable(void 0);
    this._interaction = writable({});
    this._iEvents = writable([null, null]);
    this._iClasses = writable(identity);
    this._iClass = writable(void 0);
    this._set = (key, value) => {
      if (validKey(key, this)) {
        if (parsers[key]) {
          value = parsers[key](value);
        }
        this[key].set(value);
      }
    };
    this._get = (key) => validKey(key, this) ? get_store_value(this[key]) : void 0;
    for (let plugin of plugins) {
      (_a = plugin.createStores) == null ? void 0 : _a.call(plugin, this);
    }
    if (input.view) {
      this.view.set(input.view);
    }
    let views = /* @__PURE__ */ new Set([...keys(options.views), ...keys(input.views ?? {})]);
    for (let view2 of views) {
      let defOpts = mergeOpts(options, options.views[view2] ?? {});
      let opts = mergeOpts(defOpts, input, ((_b = input.views) == null ? void 0 : _b[view2]) ?? {});
      let component = opts.component;
      filterOpts(opts, this);
      for (let key of keys(opts)) {
        let { set, _set = set, ...rest } = this[key];
        this[key] = {
          // Set value in all views
          set: ["buttonText", "theme"].includes(key) ? (value) => {
            if (isFunction(value)) {
              let result = value(defOpts[key]);
              opts[key] = result;
              set(set === _set ? result : value);
            } else {
              opts[key] = value;
              set(value);
            }
          } : (value) => {
            opts[key] = value;
            set(value);
          },
          _set,
          ...rest
        };
      }
      this.view.subscribe((newView) => {
        if (newView === view2) {
          this._viewComponent.set(component);
          if (isFunction(opts.viewDidMount)) {
            tick().then(() => opts.viewDidMount(get_store_value(this._view)));
          }
          for (let key of keys(opts)) {
            this[key]._set(opts[key]);
          }
        }
      });
    }
  }
};
function parseOpts(opts, parsers) {
  let result = { ...opts };
  for (let key of keys(parsers)) {
    if (key in result) {
      result[key] = parsers[key](result[key]);
    }
  }
  if (opts.views) {
    result.views = {};
    for (let view2 of keys(opts.views)) {
      result.views[view2] = parseOpts(opts.views[view2], parsers);
    }
  }
  return result;
}
function mergeOpts(...args) {
  let result = {};
  for (let opts of args) {
    let override = {};
    for (let key of ["buttonText", "theme"]) {
      if (isFunction(opts[key])) {
        override[key] = opts[key](result[key]);
      }
    }
    result = {
      ...result,
      ...opts,
      ...override
    };
  }
  return result;
}
function filterOpts(opts, state) {
  keys(opts).filter((key) => !validKey(key, state) || key == "view").forEach((key) => delete opts[key]);
}
function validKey(key, state) {
  return state.hasOwnProperty(key) && key[0] !== "_";
}

// node_modules/@event-calendar/core/src/Buttons.svelte
var file = "node_modules/@event-calendar/core/src/Buttons.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  return child_ctx;
}
function create_if_block_5(ctx) {
  let button_1;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[25]
    ] + ""
  );
  let t;
  let button_1_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[22](
        /*button*/
        ctx[25]
      )
    );
  }
  const block = {
    c: function create() {
      button_1 = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", { class: true });
      var button_1_nodes = children(button_1);
      t = claim_text(button_1_nodes, t_value);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[7] === /*button*/
      ctx[25] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[25]);
      add_location(button_1, file, 52, 8, 1856);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      append_hydration_dev(button_1, t);
      if (!mounted) {
        dispose = listen_dev(button_1, "click", click_handler_1, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx[5][
        /*button*/
        ctx[25]
      ] + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme, $view, buttons*/
      137 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[7] === /*button*/
      ctx[25] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[25])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(52:27) ",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let button_1;
  let button_1_class_value;
  let setContent_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button_1 = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", { class: true });
      children(button_1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25] + /*$customButtons*/
      (ctx[6][
        /*button*/
        ctx[25]
      ].active ? " " + /*$theme*/
      ctx[3].active : ""));
      add_location(button_1, file, 46, 8, 1578);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            button_1,
            "click",
            function() {
              if (is_function(
                /*$customButtons*/
                ctx[6][
                  /*button*/
                  ctx[25]
                ].click
              ))
                ctx[6][
                  /*button*/
                  ctx[25]
                ].click.apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          action_destroyer(setContent_action = setContent.call(
            null,
            button_1,
            /*$customButtons*/
            ctx[6][
              /*button*/
              ctx[25]
            ].text
          ))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$theme, buttons, $customButtons*/
      73 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25] + /*$customButtons*/
      (ctx[6][
        /*button*/
        ctx[25]
      ].active ? " " + /*$theme*/
      ctx[3].active : ""))) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*$customButtons, buttons*/
      65)
        setContent_action.update.call(
          null,
          /*$customButtons*/
          ctx[6][
            /*button*/
            ctx[25]
          ].text
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(46:37) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let button_1;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[25]
    ] + ""
  );
  let t;
  let button_1_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button_1 = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", { class: true });
      var button_1_nodes = children(button_1);
      t = claim_text(button_1_nodes, t_value);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      button_1.disabled = /*isToday*/
      ctx[1];
      add_location(button_1, file, 40, 8, 1351);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      append_hydration_dev(button_1, t);
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          /*click_handler*/
          ctx[21],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx2[5][
        /*button*/
        ctx2[25]
      ] + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (dirty & /*isToday*/
      2) {
        prop_dev(
          button_1,
          "disabled",
          /*isToday*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(40:32) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button_1;
  let i;
  let i_class_value;
  let button_1_class_value;
  let button_1_aria_label_value;
  let button_1_title_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button_1 = element("button");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        title: true
      });
      var button_1_nodes = children(button_1);
      i = claim_element(button_1_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[25]);
      add_location(i, file, 38, 9, 1259);
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      attr_dev(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/
      ctx[5].next);
      attr_dev(button_1, "title", button_1_title_value = /*$buttonText*/
      ctx[5].next);
      add_location(button_1, file, 33, 8, 1087);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      append_hydration_dev(button_1, i);
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          /*next*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/
      ctx2[5].next)) {
        attr_dev(button_1, "aria-label", button_1_aria_label_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/
      ctx2[5].next)) {
        attr_dev(button_1, "title", button_1_title_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(33:31) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let button_1;
  let i;
  let i_class_value;
  let button_1_class_value;
  let button_1_aria_label_value;
  let button_1_title_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button_1 = element("button");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        title: true
      });
      var button_1_nodes = children(button_1);
      i = claim_element(button_1_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[25]);
      add_location(i, file, 31, 9, 996);
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      attr_dev(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/
      ctx[5].prev);
      attr_dev(button_1, "title", button_1_title_value = /*$buttonText*/
      ctx[5].prev);
      add_location(button_1, file, 26, 8, 824);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      append_hydration_dev(button_1, i);
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          /*prev*/
          ctx[18],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/
      ctx2[5].prev)) {
        attr_dev(button_1, "aria-label", button_1_aria_label_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/
      ctx2[5].prev)) {
        attr_dev(button_1, "title", button_1_title_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(26:31) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let h2;
  let h2_class_value;
  let setContent_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      h2 = element("h2");
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", { class: true });
      children(h2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h2, "class", h2_class_value = /*$theme*/
      ctx[3].title);
      add_location(h2, file, 24, 8, 722);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      if (!mounted) {
        dispose = action_destroyer(setContent_action = setContent.call(
          null,
          h2,
          /*$_viewTitle*/
          ctx[4]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme*/
      8 && h2_class_value !== (h2_class_value = /*$theme*/
      ctx2[3].title)) {
        attr_dev(h2, "class", h2_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_viewTitle*/
      16)
        setContent_action.update.call(
          null,
          /*$_viewTitle*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(23:4) {#if button == 'title'}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*button*/
      ctx2[25] == "title"
    )
      return create_if_block;
    if (
      /*button*/
      ctx2[25] == "prev"
    )
      return create_if_block_1;
    if (
      /*button*/
      ctx2[25] == "next"
    )
      return create_if_block_2;
    if (
      /*button*/
      ctx2[25] == "today"
    )
      return create_if_block_3;
    if (
      /*$customButtons*/
      ctx2[6][
        /*button*/
        ctx2[25]
      ]
    )
      return create_if_block_4;
    if (
      /*button*/
      ctx2[25] != ""
    )
      return create_if_block_5;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(22:0) {#each buttons as button}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*buttons*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$theme, $_viewTitle, buttons, $buttonText, prev, next, isToday, $date, today, $customButtons, $view*/
      917759) {
        each_value = ensure_array_like_dev(
          /*buttons*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $duration;
  let $date;
  let $hiddenDays;
  let $_currentRange;
  let $theme;
  let $_viewTitle;
  let $buttonText;
  let $customButtons;
  let $view;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Buttons", slots, []);
  let { buttons } = $$props;
  let { _currentRange, _viewTitle, buttonText, customButtons, date, duration, hiddenDays, theme, view: view2 } = getContext("state");
  validate_store(_currentRange, "_currentRange");
  component_subscribe($$self, _currentRange, (value) => $$invalidate(20, $_currentRange = value));
  validate_store(_viewTitle, "_viewTitle");
  component_subscribe($$self, _viewTitle, (value) => $$invalidate(4, $_viewTitle = value));
  validate_store(buttonText, "buttonText");
  component_subscribe($$self, buttonText, (value) => $$invalidate(5, $buttonText = value));
  validate_store(customButtons, "customButtons");
  component_subscribe($$self, customButtons, (value) => $$invalidate(6, $customButtons = value));
  validate_store(date, "date");
  component_subscribe($$self, date, (value) => $$invalidate(2, $date = value));
  validate_store(duration, "duration");
  component_subscribe($$self, duration, (value) => $$invalidate(23, $duration = value));
  validate_store(hiddenDays, "hiddenDays");
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(24, $hiddenDays = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(3, $theme = value));
  validate_store(view2, "view");
  component_subscribe($$self, view2, (value) => $$invalidate(7, $view = value));
  let today2 = setMidnight(createDate()), isToday;
  function prev() {
    set_store_value(date, $date = prevDate($date, $duration, $hiddenDays), $date);
  }
  function next() {
    set_store_value(date, $date = nextDate($date, $duration), $date);
  }
  $$self.$$.on_mount.push(function() {
    if (buttons === void 0 && !("buttons" in $$props || $$self.$$.bound[$$self.$$.props["buttons"]])) {
      console.warn("<Buttons> was created without expected prop 'buttons'");
    }
  });
  const writable_props = ["buttons"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Buttons> was created with unknown prop '${key}'`);
  });
  const click_handler = () => set_store_value(date, $date = cloneDate(today2), $date);
  const click_handler_1 = (button) => set_store_value(view2, $view = button, $view);
  $$self.$$set = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
  };
  $$self.$capture_state = () => ({
    getContext,
    createDate,
    cloneDate,
    setContent,
    setMidnight,
    nextDate,
    prevDate,
    buttons,
    _currentRange,
    _viewTitle,
    buttonText,
    customButtons,
    date,
    duration,
    hiddenDays,
    theme,
    view: view2,
    today: today2,
    isToday,
    prev,
    next,
    $duration,
    $date,
    $hiddenDays,
    $_currentRange,
    $theme,
    $_viewTitle,
    $buttonText,
    $customButtons,
    $view
  });
  $$self.$inject_state = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
    if ("_currentRange" in $$props2)
      $$invalidate(8, _currentRange = $$props2._currentRange);
    if ("_viewTitle" in $$props2)
      $$invalidate(9, _viewTitle = $$props2._viewTitle);
    if ("buttonText" in $$props2)
      $$invalidate(10, buttonText = $$props2.buttonText);
    if ("customButtons" in $$props2)
      $$invalidate(11, customButtons = $$props2.customButtons);
    if ("date" in $$props2)
      $$invalidate(12, date = $$props2.date);
    if ("duration" in $$props2)
      $$invalidate(13, duration = $$props2.duration);
    if ("hiddenDays" in $$props2)
      $$invalidate(14, hiddenDays = $$props2.hiddenDays);
    if ("theme" in $$props2)
      $$invalidate(15, theme = $$props2.theme);
    if ("view" in $$props2)
      $$invalidate(16, view2 = $$props2.view);
    if ("today" in $$props2)
      $$invalidate(17, today2 = $$props2.today);
    if ("isToday" in $$props2)
      $$invalidate(1, isToday = $$props2.isToday);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_currentRange*/
    1048576) {
      $:
        $$invalidate(1, isToday = today2 >= $_currentRange.start && today2 < $_currentRange.end || null);
    }
  };
  return [
    buttons,
    isToday,
    $date,
    $theme,
    $_viewTitle,
    $buttonText,
    $customButtons,
    $view,
    _currentRange,
    _viewTitle,
    buttonText,
    customButtons,
    date,
    duration,
    hiddenDays,
    theme,
    view2,
    today2,
    prev,
    next,
    $_currentRange,
    click_handler,
    click_handler_1
  ];
}
var Buttons = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { buttons: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Buttons",
      options,
      id: create_fragment.name
    });
  }
  get buttons() {
    throw new Error("<Buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttons(value) {
    throw new Error("<Buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Buttons_default = Buttons;

// node_modules/@event-calendar/core/src/Toolbar.svelte
var file2 = "node_modules/@event-calendar/core/src/Toolbar.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let buttons_1;
  let current;
  buttons_1 = new Buttons_default({
    props: { buttons: (
      /*buttons*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(buttons_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(buttons_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(buttons_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttons_1_changes = {};
      if (dirty & /*sections*/
      1)
        buttons_1_changes.buttons = /*buttons*/
        ctx2[8];
      buttons_1.$set(buttons_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(buttons_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(29:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let buttons_1;
  let div_class_value;
  let current;
  buttons_1 = new Buttons_default({
    props: { buttons: (
      /*buttons*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(buttons_1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(buttons_1.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].buttonGroup);
      add_location(div, file2, 25, 20, 638);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(buttons_1, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttons_1_changes = {};
      if (dirty & /*sections*/
      1)
        buttons_1_changes.buttons = /*buttons*/
        ctx2[8];
      buttons_1.$set(buttons_1_changes);
      if (!current || dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].buttonGroup)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(buttons_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(25:16) {#if buttons.length > 1}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*buttons*/
      ctx2[8].length > 1
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(24:12) {#each sections[key] as buttons}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*sections*/
    ctx[0][
      /*key*/
      ctx[5]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "ec-" + /*key*/
      ctx[5]);
      add_location(div, file2, 22, 8, 509);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, sections*/
      3) {
        each_value_1 = ensure_array_like_dev(
          /*sections*/
          ctx2[0][
            /*key*/
            ctx2[5]
          ]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*sections*/
      1 && div_class_value !== (div_class_value = "ec-" + /*key*/
      ctx2[5])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(22:4) {#each keys(sections) as key}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let nav;
  let nav_class_value;
  let current;
  let each_value = ensure_array_like_dev(keys(
    /*sections*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      nav = element("nav");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nav_nodes);
      }
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(nav, "class", nav_class_value = /*$theme*/
      ctx[1].toolbar);
      add_location(nav, file2, 20, 0, 436);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(nav, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*sections, $theme*/
      3) {
        each_value = ensure_array_like_dev(keys(
          /*sections*/
          ctx2[0]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(nav, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      2 && nav_class_value !== (nav_class_value = /*$theme*/
      ctx2[1].toolbar)) {
        attr_dev(nav, "class", nav_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $headerToolbar;
  let $theme;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toolbar", slots, []);
  let { headerToolbar, theme } = getContext("state");
  validate_store(headerToolbar, "headerToolbar");
  component_subscribe($$self, headerToolbar, (value) => $$invalidate(4, $headerToolbar = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  let sections = { start: [], center: [], end: [] };
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Toolbar> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    keys,
    Buttons: Buttons_default,
    headerToolbar,
    theme,
    sections,
    $headerToolbar,
    $theme
  });
  $$self.$inject_state = ($$props2) => {
    if ("headerToolbar" in $$props2)
      $$invalidate(2, headerToolbar = $$props2.headerToolbar);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("sections" in $$props2)
      $$invalidate(0, sections = $$props2.sections);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sections, $headerToolbar*/
    17) {
      $: {
        for (let key of keys(sections)) {
          $$invalidate(0, sections[key] = $headerToolbar[key].split(" ").map((group) => group.split(",")), sections);
        }
      }
    }
  };
  return [sections, $theme, headerToolbar, theme, $headerToolbar];
}
var Toolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toolbar",
      options,
      id: create_fragment2.name
    });
  }
};
var Toolbar_default = Toolbar;

// node_modules/@event-calendar/core/src/Auxiliary.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*component*/
    ctx[11]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$_auxiliary*/
      1 && switch_value !== (switch_value = /*component*/
      ctx2[11])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(24:0) {#each $_auxiliary as component}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*$_auxiliary*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$_auxiliary*/
      1) {
        each_value = ensure_array_like_dev(
          /*$_auxiliary*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $_view;
  let $datesSet;
  let $_activeRange;
  let $_auxiliary;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Auxiliary", slots, []);
  let { datesSet, _auxiliary, _activeRange, _queue, _view } = getContext("state");
  validate_store(datesSet, "datesSet");
  component_subscribe($$self, datesSet, (value) => $$invalidate(7, $datesSet = value));
  validate_store(_auxiliary, "_auxiliary");
  component_subscribe($$self, _auxiliary, (value) => $$invalidate(0, $_auxiliary = value));
  validate_store(_activeRange, "_activeRange");
  component_subscribe($$self, _activeRange, (value) => $$invalidate(5, $_activeRange = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(6, $_view = value));
  let debounceHandle = {};
  function runDatesSet(_activeRange2) {
    if (isFunction($datesSet)) {
      debounce(
        () => $datesSet({
          start: toLocalDate(_activeRange2.start),
          end: toLocalDate(_activeRange2.end),
          startStr: toISOString(_activeRange2.start),
          endStr: toISOString(_activeRange2.end),
          view: toViewWithLocalDates($_view)
        }),
        debounceHandle,
        _queue
      );
    }
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Auxiliary> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    debounce,
    toISOString,
    toLocalDate,
    toViewWithLocalDates,
    isFunction,
    datesSet,
    _auxiliary,
    _activeRange,
    _queue,
    _view,
    debounceHandle,
    runDatesSet,
    $_view,
    $datesSet,
    $_activeRange,
    $_auxiliary
  });
  $$self.$inject_state = ($$props2) => {
    if ("datesSet" in $$props2)
      $$invalidate(1, datesSet = $$props2.datesSet);
    if ("_auxiliary" in $$props2)
      $$invalidate(2, _auxiliary = $$props2._auxiliary);
    if ("_activeRange" in $$props2)
      $$invalidate(3, _activeRange = $$props2._activeRange);
    if ("_queue" in $$props2)
      _queue = $$props2._queue;
    if ("_view" in $$props2)
      $$invalidate(4, _view = $$props2._view);
    if ("debounceHandle" in $$props2)
      debounceHandle = $$props2.debounceHandle;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_activeRange*/
    32) {
      $:
        runDatesSet($_activeRange);
    }
  };
  return [$_auxiliary, datesSet, _auxiliary, _activeRange, _view, $_activeRange];
}
var Auxiliary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Auxiliary",
      options,
      id: create_fragment3.name
    });
  }
};
var Auxiliary_default = Auxiliary;

// node_modules/@event-calendar/core/src/Calendar.svelte
var file3 = "node_modules/@event-calendar/core/src/Calendar.svelte";
function create_fragment4(ctx) {
  let div;
  let toolbar;
  let t0;
  let switch_instance;
  let div_class_value;
  let div_role_value;
  let t1;
  let auxiliary;
  let current;
  let mounted;
  let dispose;
  toolbar = new Toolbar_default({ $$inline: true });
  var switch_value = (
    /*$_viewComponent*/
    ctx[5]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  auxiliary = new Auxiliary_default({ $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      create_component(toolbar.$$.fragment);
      t0 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t1 = space();
      create_component(auxiliary.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children(div);
      claim_component(toolbar.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      claim_component(auxiliary.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].calendar + " " + /*$theme*/
      ctx[1].view + /*$_scrollable*/
      (ctx[0] ? " " + /*$theme*/
      ctx[1].withScroll : "") + /*$_iClass*/
      (ctx[2] ? " " + /*$theme*/
      ctx[1][
        /*$_iClass*/
        ctx[2]
      ] : ""));
      attr_dev(div, "role", div_role_value = listView(
        /*$view*/
        ctx[4]
      ) ? "list" : "table");
      set_style(
        div,
        "height",
        /*$height*/
        ctx[3]
      );
      add_location(div, file3, 140, 0, 3539);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(toolbar, div, null);
      append_hydration_dev(div, t0);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      insert_hydration_dev(target, t1, anchor);
      mount_component(auxiliary, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "resize",
          /*recheckScrollable*/
          ctx[20],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$_viewComponent*/
      32 && switch_value !== (switch_value = /*$_viewComponent*/
      ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty[0] & /*$theme, $_scrollable, $_iClass*/
      7 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].calendar + " " + /*$theme*/
      ctx2[1].view + /*$_scrollable*/
      (ctx2[0] ? " " + /*$theme*/
      ctx2[1].withScroll : "") + /*$_iClass*/
      (ctx2[2] ? " " + /*$theme*/
      ctx2[1][
        /*$_iClass*/
        ctx2[2]
      ] : ""))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*$view*/
      16 && div_role_value !== (div_role_value = listView(
        /*$view*/
        ctx2[4]
      ) ? "list" : "table")) {
        attr_dev(div, "role", div_role_value);
      }
      if (dirty[0] & /*$height*/
      8) {
        set_style(
          div,
          "height",
          /*$height*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(auxiliary.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toolbar.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(auxiliary.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t1);
      }
      destroy_component(toolbar);
      if (switch_instance)
        destroy_component(switch_instance);
      destroy_component(auxiliary, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $_bodyEl;
  let $_scrollable;
  let $_queue2;
  let $_queue;
  let $hiddenDays;
  let $duration;
  let $date;
  let $_interaction;
  let $_events;
  let $theme;
  let $_iClass;
  let $height;
  let $view;
  let $_viewComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Calendar", slots, []);
  let { plugins = [] } = $$props;
  let { options = {} } = $$props;
  let state = new state_default(plugins, options);
  setContext("state", state);
  let { _viewComponent, _bodyEl, _interaction, _iClass, _events, _queue, _queue2, _tasks, _scrollable, date, duration, hiddenDays, height: height2, theme, view: view2 } = state;
  validate_store(_viewComponent, "_viewComponent");
  component_subscribe($$self, _viewComponent, (value) => $$invalidate(5, $_viewComponent = value));
  validate_store(_bodyEl, "_bodyEl");
  component_subscribe($$self, _bodyEl, (value) => $$invalidate(36, $_bodyEl = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(42, $_interaction = value));
  validate_store(_iClass, "_iClass");
  component_subscribe($$self, _iClass, (value) => $$invalidate(2, $_iClass = value));
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(43, $_events = value));
  validate_store(_queue, "_queue");
  component_subscribe($$self, _queue, (value) => $$invalidate(38, $_queue = value));
  validate_store(_queue2, "_queue2");
  component_subscribe($$self, _queue2, (value) => $$invalidate(37, $_queue2 = value));
  validate_store(_scrollable, "_scrollable");
  component_subscribe($$self, _scrollable, (value) => $$invalidate(0, $_scrollable = value));
  validate_store(date, "date");
  component_subscribe($$self, date, (value) => $$invalidate(41, $date = value));
  validate_store(duration, "duration");
  component_subscribe($$self, duration, (value) => $$invalidate(40, $duration = value));
  validate_store(hiddenDays, "hiddenDays");
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(39, $hiddenDays = value));
  validate_store(height2, "height");
  component_subscribe($$self, height2, (value) => $$invalidate(3, $height = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  validate_store(view2, "view");
  component_subscribe($$self, view2, (value) => $$invalidate(4, $view = value));
  let prevOptions = { ...options };
  function setOption(name, value) {
    state._set(name, value);
    return this;
  }
  function getOption(name) {
    let value = state._get(name);
    return value instanceof Date ? toLocalDate(value) : value;
  }
  function refetchEvents() {
    state._fetchedRange.set({ start: void 0, end: void 0 });
    return this;
  }
  function getEvents() {
    return $_events.map(toEventWithLocalDates);
  }
  function getEventById(id) {
    for (let event of $_events) {
      if (event.id == id) {
        return toEventWithLocalDates(event);
      }
    }
    return null;
  }
  function addEvent(event) {
    event = createEvents([event])[0];
    $_events.push(event);
    _events.set($_events);
    return event;
  }
  function updateEvent(event) {
    for (let e of $_events) {
      if (e.id == event.id) {
        event = createEvents([event])[0];
        assign(e, event);
        _events.set($_events);
        return event;
      }
    }
    return null;
  }
  function removeEventById(id) {
    let idx = $_events.findIndex((event) => event.id == id);
    if (idx >= 0) {
      $_events.splice(idx, 1);
      _events.set($_events);
    }
    return this;
  }
  function getView() {
    return toViewWithLocalDates(get_store_value(state._view));
  }
  function unselect() {
    var _a;
    (_a = $_interaction.action) == null ? void 0 : _a.unselect();
    return this;
  }
  function dateFromPoint(x, y) {
    let dayEl = getElementWithPayload(x, y);
    if (dayEl) {
      let info = getPayload(dayEl)(x, y);
      info.date = toLocalDate(info.date);
      return info;
    }
    return null;
  }
  function next() {
    set_store_value(date, $date = nextDate($date, $duration), $date);
    return this;
  }
  function prev() {
    set_store_value(date, $date = prevDate($date, $duration, $hiddenDays), $date);
    return this;
  }
  beforeUpdate(() => {
    flushDebounce($_queue);
  });
  afterUpdate(() => {
    flushDebounce($_queue2);
    task(recheckScrollable, null, _tasks);
  });
  function recheckScrollable() {
    if ($_bodyEl) {
      set_store_value(_scrollable, $_scrollable = hasYScroll($_bodyEl), $_scrollable);
    }
  }
  const writable_props = ["plugins", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Calendar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("options" in $$props2)
      $$invalidate(22, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    setContext,
    beforeUpdate,
    afterUpdate,
    get: get_store_value,
    diff,
    State: state_default,
    Toolbar: Toolbar_default,
    Auxiliary: Auxiliary_default,
    assign,
    createEvents,
    toEventWithLocalDates,
    toViewWithLocalDates,
    toLocalDate,
    getElementWithPayload,
    getPayload,
    flushDebounce,
    hasYScroll,
    listView,
    task,
    prevDate,
    nextDate,
    plugins,
    options,
    state,
    _viewComponent,
    _bodyEl,
    _interaction,
    _iClass,
    _events,
    _queue,
    _queue2,
    _tasks,
    _scrollable,
    date,
    duration,
    hiddenDays,
    height: height2,
    theme,
    view: view2,
    prevOptions,
    setOption,
    getOption,
    refetchEvents,
    getEvents,
    getEventById,
    addEvent,
    updateEvent,
    removeEventById,
    getView,
    unselect,
    dateFromPoint,
    next,
    prev,
    recheckScrollable,
    $_bodyEl,
    $_scrollable,
    $_queue2,
    $_queue,
    $hiddenDays,
    $duration,
    $date,
    $_interaction,
    $_events,
    $theme,
    $_iClass,
    $height,
    $view,
    $_viewComponent
  });
  $$self.$inject_state = ($$props2) => {
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("options" in $$props2)
      $$invalidate(22, options = $$props2.options);
    if ("state" in $$props2)
      state = $$props2.state;
    if ("_viewComponent" in $$props2)
      $$invalidate(6, _viewComponent = $$props2._viewComponent);
    if ("_bodyEl" in $$props2)
      $$invalidate(7, _bodyEl = $$props2._bodyEl);
    if ("_interaction" in $$props2)
      $$invalidate(8, _interaction = $$props2._interaction);
    if ("_iClass" in $$props2)
      $$invalidate(9, _iClass = $$props2._iClass);
    if ("_events" in $$props2)
      $$invalidate(10, _events = $$props2._events);
    if ("_queue" in $$props2)
      $$invalidate(11, _queue = $$props2._queue);
    if ("_queue2" in $$props2)
      $$invalidate(12, _queue2 = $$props2._queue2);
    if ("_tasks" in $$props2)
      _tasks = $$props2._tasks;
    if ("_scrollable" in $$props2)
      $$invalidate(13, _scrollable = $$props2._scrollable);
    if ("date" in $$props2)
      $$invalidate(14, date = $$props2.date);
    if ("duration" in $$props2)
      $$invalidate(15, duration = $$props2.duration);
    if ("hiddenDays" in $$props2)
      $$invalidate(16, hiddenDays = $$props2.hiddenDays);
    if ("height" in $$props2)
      $$invalidate(17, height2 = $$props2.height);
    if ("theme" in $$props2)
      $$invalidate(18, theme = $$props2.theme);
    if ("view" in $$props2)
      $$invalidate(19, view2 = $$props2.view);
    if ("prevOptions" in $$props2)
      $$invalidate(46, prevOptions = $$props2.prevOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*options*/
    4194304) {
      $:
        for (let [name, value] of diff(options, prevOptions)) {
          setOption(name, value);
        }
    }
  };
  return [
    $_scrollable,
    $theme,
    $_iClass,
    $height,
    $view,
    $_viewComponent,
    _viewComponent,
    _bodyEl,
    _interaction,
    _iClass,
    _events,
    _queue,
    _queue2,
    _scrollable,
    date,
    duration,
    hiddenDays,
    height2,
    theme,
    view2,
    recheckScrollable,
    plugins,
    options,
    setOption,
    getOption,
    refetchEvents,
    getEvents,
    getEventById,
    addEvent,
    updateEvent,
    removeEventById,
    getView,
    unselect,
    dateFromPoint,
    next,
    prev
  ];
}
var Calendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        plugins: 21,
        options: 22,
        setOption: 23,
        getOption: 24,
        refetchEvents: 25,
        getEvents: 26,
        getEventById: 27,
        addEvent: 28,
        updateEvent: 29,
        removeEventById: 30,
        getView: 31,
        unselect: 32,
        dateFromPoint: 33,
        next: 34,
        prev: 35
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment4.name
    });
  }
  get plugins() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOption() {
    return this.$$.ctx[23];
  }
  set setOption(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getOption() {
    return this.$$.ctx[24];
  }
  set getOption(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refetchEvents() {
    return this.$$.ctx[25];
  }
  set refetchEvents(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getEvents() {
    return this.$$.ctx[26];
  }
  set getEvents(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getEventById() {
    return this.$$.ctx[27];
  }
  set getEventById(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addEvent() {
    return this.$$.ctx[28];
  }
  set addEvent(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateEvent() {
    return this.$$.ctx[29];
  }
  set updateEvent(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeEventById() {
    return this.$$.ctx[30];
  }
  set removeEventById(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getView() {
    return this.$$.ctx[31];
  }
  set getView(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unselect() {
    return this.$$.ctx[32];
  }
  set unselect(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dateFromPoint() {
    return this.$$.ctx[33];
  }
  set dateFromPoint(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get next() {
    return this.$$.ctx[34];
  }
  set next(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get prev() {
    return this.$$.ctx[35];
  }
  set prev(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Calendar_default = Calendar;

export {
  keyEnter,
  setContent,
  outsideEvent,
  DAY_IN_SECONDS,
  createDate,
  createDuration,
  cloneDate,
  addDuration,
  subtractDuration,
  addDay,
  subtractDay,
  setMidnight,
  toLocalDate,
  toISOString,
  datesEqual,
  nextClosestDay,
  prevClosestDay,
  noTimePart,
  copyTime,
  toSeconds,
  nextDate,
  prevDate,
  assign,
  keys,
  floor,
  ceil,
  min,
  max,
  symbol,
  isArray,
  isFunction,
  run,
  runAll,
  noop2 as noop,
  identity,
  debounce,
  flushDebounce,
  task,
  setPayload,
  hasPayload,
  getPayload,
  createElement,
  hasYScroll,
  rect,
  ancestor,
  height,
  getElementWithPayload,
  listen,
  createView,
  toViewWithLocalDates,
  listView,
  timelineView,
  createEvents,
  createEventSources,
  createEventChunk,
  sortEventChunks,
  createEventContent,
  handleZeroDurationChunk,
  createEventClasses,
  toEventWithLocalDates,
  cloneEvent,
  prepareEventChunks,
  repositionEvent,
  runReposition,
  eventIntersects,
  helperEvent,
  bgEvent,
  previewEvent,
  ghostEvent,
  pointerEvent,
  btnTextDay,
  btnTextWeek,
  btnTextMonth,
  btnTextYear,
  themeView,
  createResources,
  createResource,
  resourceBackgroundColor,
  resourceTextColor,
  intl,
  intlRange,
  viewResources,
  createTimes,
  createSlotTimeLimits,
  Calendar_default
};
//# sourceMappingURL=chunk-DJCHSTZL.js.map
